<html>

<head>
    <title>BADACS</title>
    <link href="{{SPLUNKWEB_URL_PREFIX}}/static/build/css/bootstrap-enterprise.css" rel="stylesheet" type="text/css"/>
    <!--<link href="{{SPLUNKWEB_URL_PREFIX}}/static/build/css/splunkjs-dashboard.css" rel="stylesheet" type="text/css"/>-->
    <link href="{{SPLUNKWEB_URL_PREFIX}}/static/app/badacs/keen-ui.min.css" rel="stylesheet" type="text/css" />   

    <style>
        *,
        *::before,
        *::after {
            box-sizing: border-box;
        }

        /* Material Icons */
        @font-face {
            font-family: 'Material Icons';
            font-style: normal;
            font-weight: 400;
            src: local('Material Icons'),
                local('MaterialIcons-Regular'),
                url({{SPLUNKWEB_URL_PREFIX}}/static/app/badacs/material-icons.woff2) format('woff2');
        }
        .material-icons {
            font-family: 'Material Icons';
            font-weight: normal;
            font-style: normal;
            font-size: 24px;
            display: inline-block;
            line-height: 1;
            text-transform: none;
            letter-spacing: normal;
            word-wrap: normal;
            white-space: nowrap;
            direction: ltr;
            -webkit-font-smoothing: antialiased;
            text-rendering: optimizeLegibility;
            -moz-osx-font-smoothing: grayscale;
            font-feature-settings: 'liga';
        }

        .settings {
            /*grid-template-rows: repeat(auto-fill, minmax(1.5em, 1fr));*/
        }

        .loading {
            height: 0.25rem
        }

        .buttons {
            display: grid;
            grid-template-columns: repeat(4, minmax(0, 1fr));
            grid-gap: 0.5em;
        }

        .ui-button-group {
            gap: .5rem;
        }

        /* Use disabled Tab as title */
        .ui-tab-header-item.is-disabled {
            opacity: 1;
        }

        /* CONF GRID */
        .grid {
            display: grid;
            column-gap: 1rem;
            align-items: center;
            /*grid-auto-rows: 2rem;*/
            font-family: Consolas, ui-monospace, monospace;
        }
        .tight {
            margin-bottom: 0;
        }

        .tight > ui-textbox__input {
            margin-bottom: 0;
        }

        .same {
            background-color: #d1ffd1;
        }
        .diff {
            background-color: #ffd1d1;
        }

        .row1 {
            grid-row: 1;
        }
        .row2 {
            grid-row: 2;
        }
        .row3 {
            grid-row: 3;
        }
        .row4 {
            grid-row: 4;
        }
        .row5 {
            grid-row: 5;
            height: .25rem;
        }
        .col1 {
            grid-column: 1;
        }
        .col1-2 {
            grid-column: 1 / 3;
        }
        .col2 {
            grid-column: 2;
        }
        .colall {
            grid-column: 1 / -1;
        }

        .acs-input {
            margin-bottom: 0;
        }

        .half-input {
            width: 50%;
        }
        .addable {
            display: inline-block;
        }

        .removeable {
            display: inline-block;
            line-height: 1.125rem;
            vertical-align: middle;
        }

        .flex {
            display: flex;
            flex-wrap: nowrap;
            align-items: center;
            gap: 1rem;
        }

        .grow {
            flex-grow: 1;
        }

        .name {
            font-size: 1.25rem;
            font-weight: bold;
            vertical-align: middle;
        }

        .two {
            display: grid;
            column-gap: 1rem;
            grid-template-columns: 1fr 1fr;
        }

    </style>
</head>

<body>
    <header>
        <a class="navSkip" href="#navSkip" tabindex="1"></a>
        <div class="header splunk-header">
            <div id="placeholder-splunk-bar">
                <a href="{{SPLUNKWEB_URL_PREFIX}}/app/launcher/home" class="brand" title="splunk &gt; listen to your data">splunk<strong>&gt;</strong></a>
            </div>
        </div>
    </header>
    <div id="vue" class="main-section-body" data-role="main">
        <ui-tabs>
            <ui-tab disabled>
                <div slot="header" style="color:black;">Brett Adams' Dangerous Admin Configuration Service</div>
            </ui-tab>
            <ui-tab id="home" title="Home" selected>
                <h1>Welcome</h1>
                <p>This app provides a graphical user inferace to the Splunk Admin Configuration Service. All actions performed in this app are privilleged and are performed using the sc_admin role. Private App management has not yet been implemented.</p>
                <p>Created and supported by <a target="_blank" href="https://splunkbase.splunk.com/apps/#/author/s7orm">Brett Adams</a>. The app is still under active development, so please raise issues on <a target="_blank" href="https://github.com/Bre77/badacs/issues">GitHub</a>.</p>
                <h3>Disclaimer</h3>
                <p>This application is offered under the Splunk general terms for third party applications avaliable at <a href="https://www.splunk.com/en_us/legal/splunk-general-terms.html#third-party" target="_blank"/>https://www.splunk.com/en_us/legal/splunk-general-terms.html#third-party</a>.</p>
                <h3>Current Stacks</h3>
                <ul>
                    <li v-for="stack in Object.keys(config)"><a :href="`https://${stack}.splunkcloud.com`" target="_blank">{{stack}}</a></li>
                </ul>
                </table>
                <h3>Add Stack</h3>
                <div class="flex">
                    <ui-textbox class="grow" label="Stack Name" v-model="addstack_host" help="This is the subdomain infront of .splunkcloud.com" :error="addstack_host_error"></ui-textbox>
                    <ui-textbox class="grow" label="Auth Token" v-model="addstack_auth" help="This must be an auth token for a user with the sc_admin role" :error="addstack_auth_error"></ui-textbox>
                </div>
                <div class="flex">
                    <ui-button @click="AddStack()" :disabled="!Boolean(addstack_host && addstack_auth)">Submit</ui-button>
                    <ui-checkbox v-model="addstack_shared">Shared</ui-checkbox>
                </div>
                <h3>Options</h3>
                <ui-select :options="setting_columns_options" v-model="setting_columns_option">Columns to display</ui-select>
            </ui-tab>
            <ui-tab id="netin" class="grid" title="Inbound Allowlists" :style="{'grid-template-columns': `repeat(${this.setting_columns}, 1fr)`}" @select="TabChange(NetInGet)">
                <template v-for="(c,i) in active_columns">
                    <ui-select class="settings tight row1" :style="{'grid-column':i+1}" :options="acs_servers_options" :disabled="acs_servers_options.length == 0" placeholder="Please select a server" v-model="c.server" @dropdown-close="NetInGet(c)" label="Stack" :invalid="!c.server"></ui-select>
                    <div class="loading" :style="{'grid-column':i+1}"><ui-progress-linear v-show="c.loading"></ui-progress-linear></div>
                </template>
                <template v-for="aspect in Object.keys(ACS_NETWORK_ENDPOINTS)">
                    
                    <div v-for="(c,i) in active_columns" v-if="netin_data.hasOwnProperty(c.server)" :style="{'grid-column':i+1}">
                        <div><b>{{aspect}}</b></div>
                        <removable v-if="netin_data[c.server].hasOwnProperty(aspect)" v-for="(value,x) in netin_data[c.server][aspect]" :id="i+aspect+x" :value="value" :action="NetInRemove" :args="[c.server,aspect,x]"></removable>
                        <addable :action="NetInAdd" :args="[c.server,aspect]" placeholder="Add CIDR">
                    </div>
                </template>
            </ui-tab>
            <ui-tab id="netout" class="grid" title="Outbound Allowlists" :style="{'grid-template-columns': `repeat(${this.setting_columns}, 1fr)`}" @select="TabChange(NetOutGet)">
                <template v-for="(c,i) in active_columns">
                    <ui-select class="settings tight row1" :style="{'grid-column':i+1}" :options="acs_servers_options" :disabled="acs_servers_options.length == 0" placeholder="Please select a server" v-model="c.server" @dropdown-close="NetOutGet(c)" label="Stack" :invalid="!c.server"></ui-select>
                    <div class="loading" :style="{'grid-column':i+1}"><ui-progress-linear v-show="c.loading"></ui-progress-linear></div>
                </template>
                <template v-for="(c,i) in active_columns" v-if="netout_data.hasOwnProperty(c.server)">
                    <div :style="{'grid-column':i+1}">
                        <template v-for="(port,x) in netout_data[c.server]">
                            <div><b>{{port.port}}</b></div>
                            <removable v-for="(subnet,y) in port.destinationRanges" :id="i+x" :value="subnet" :action="NetOutRemove" :args="[c.server,port.port,x,y]"></removable>
                        </template>
                        <addport :action="NetOutAdd" :stack="c.server"></addport>
                    </div>
                </template>
                
            </ui-tab>
            <ui-tab id="hec" class="grid" title="HEC" :style="{'grid-template-columns': `repeat(${this.setting_columns}, 1fr)`}" @select="TabChange(HecGet)">
                <ui-select v-for="(c,i) in active_columns" class="settings tight row1" :style="{'grid-column':i+1}" :options="acs_servers_options" :disabled="acs_servers_options.length == 0" placeholder="Please select a server" v-model="c.server" @dropdown-close="HecGet(c)" label="Stack" :invalid="!c.server"></ui-select>
                <div v-for="(c,i) in active_columns" class="loading row2" :style="{'grid-column':i+1}"><ui-progress-linear v-show="c.loading"></ui-progress-linear></div>
                <div v-for="(c,i) in active_columns" class="row3" :style="{'grid-column':i+1}"><addable :action="HecNew" :args="[c.server]" placeholder="New Token"></addable></div>
                <div v-for="(c,i) in active_columns" class="row4" v-if="hec_data.hasOwnProperty(c.server)" :style="{'grid-column':i+1}">
                    <div v-if="hec_data[c.server] == null && !c.loading">
                        <p>HEC data wasnt avalible from ACS.</p>
                        <p>If this is a classic stack, HEC cannot be managed using ACS. <a href="https://docs.splunk.com/Documentation/SplunkCloud/8.2.2111/Config/ACSreqs#ACS_compatibility_matrix">(docs)</a></p>
                        <p>Splunk Cloud classic HEC will be avaliable in a future release of <a href="https://splunkbase.splunk.com/app/6277/">BADRCS</a></p>
                    </div>
                    <div v-else v-for="hec,token in hec_data[c.server]" style="margin: .5rem 0;" class="two">
                        <div class="name" style="grid-column: 1 / 3;">{{token}}</div>
                        <ui-textbox class="tight" v-model="hec.name">Name</ui-textbox>
                        <ui-textbox class="tight" v-model="hec.defaultHost">Host</ui-textbox>
                        <ui-textbox class="tight" v-model="hec.defaultSource">Source</ui-textbox>
                        <ui-textbox class="tight" v-model="hec.defaultSourcetype">Sourcetype</ui-textbox>
                        <ui-select class="tight" :options="Object.keys(idx_data[c.server] || {})" v-model="hec.defaultIndex">Default Index</ui-select>
                        <ui-select class="tight" has-search multiple :options="Options(hec.allowedIndexes, Object.keys(idx_data[c.server] || {}))" v-model="hec.allowedIndexes">Allowed Indexes</ui-select>
                        <div class="flex" style="grid-column: 1 / 3;">
                            <ui-checkbox class="tight" v-model="hec.useAck">Use ACK</ui-checkbox>
                            <ui-checkbox class="tight" v-model="hec.disabled">Disabled</ui-checkbox>
                            <saveable :action="HecChange" :args="[c.server,hec]"></saveable>
                        </div>
                    </div>
                </div>
            </ui-tab>
            <ui-tab id="idx" class="grid" title="Indexes" :style="{'grid-template-columns': `repeat(${this.setting_columns}, 1fr)`}" @select="TabChange(IdxGet)">
                <template v-for="(c,i) in active_columns">
                    <ui-select class="settings tight row1" :style="{'grid-column':i+1}" :options="acs_servers_options" :disabled="acs_servers_options.length == 0" placeholder="Please select a server" v-model="c.server" @dropdown-close="IdxGet(c)" label="Stack" :invalid="!c.server"></ui-select>
                    <div class="loading" :style="{'grid-column':i+1}"><ui-progress-linear v-show="c.loading"></ui-progress-linear></div>
                </template>
                <div v-for="(c,i) of active_columns" v-if="idx_data[c.server]" :style="{'grid-column':i+1}">
                    <div v-if="idx_data[c.server] == null && !c.loading">
                        <p>Index data wasnt avalible from ACS.</p>
                        <p>If this is a classic stack, Indexes cannot be managed using ACS. <a href="https://docs.splunk.com/Documentation/SplunkCloud/8.2.2111/Config/ACSreqs#ACS_compatibility_matrix">(docs)</a></p>
                        <p>Splunk Cloud classic index management will be avaliable in a future release of <a href="https://splunkbase.splunk.com/app/6277/">BADRCS</a></p>
                    </div>
                    <template v-else v-for="idx in idx_list" v-if="idx_data[c.server][idx]">
                        <div><span class="material-icons" :title="idx.datatype">{{IDX_ICON[idx_data[c.server][idx].datatype]}}</span><span class="name">&nbsp;{{idx}}</span> (Events:&nbsp;{{idx_data[c.server][idx].totalEventCount}}&nbsp;Size:&nbsp;{{idx_data[c.server][idx].totalRawSizeMB}}MB)</div>
                        <div class="flex">
                            <ui-textbox class="grow tight" type="number" :min="1" v-model.number="idx_data[c.server][idx].searchableDays">Searchable Days</ui-textbox>
                            <ui-textbox class="grow tight" type="number" :min="10" v-model.number="idx_data[c.server][idx].maxDataSizeMB">Max Data Size (MB)</ui-textbox>
                            <saveable :action="IdxChange" :args="[c.server,idx_data[c.server][idx]]"></saveable>
                        </div>
                    </template>
                </div>
            </ui-tab>
        </ui-tabs>
        <ui-snackbar-container ref="errorbar" position="center"></ui-snackbar-container>
    </div>
    <!--<script src="{{SPLUNKWEB_URL_PREFIX}}/static/js/i18n.js"></script>-->
    <!--<script src="{{SPLUNKWEB_URL_PREFIX}}/i18ncatalog?autoload=1"></script>-->
    <!--<script src="{{SPLUNKWEB_URL_PREFIX}}/static/build/simplexml/index.js"></script>-->
    <script>
        function i18n_register(catalog) {return}
    </script>
    <script src="{{SPLUNKWEB_URL_PREFIX}}/config?autoload=1" crossorigin="use-credentials"></script>
    <script src="{{SPLUNKWEB_URL_PREFIX}}/static/app/badacs/vue.js"></script>
    <script src="{{SPLUNKWEB_URL_PREFIX}}/static/app/badacs/keen-ui.js"></script>
    <script>
        const REST_ENDPOINT = `/${window.$C.LOCALE}/splunkd/__raw/services/badacs?output_mode=json`
        const CSRF = /splunkweb_csrf_token_\d+=(\d+)/.exec(document.cookie)[1]
        const COLUMNS_MAX = 8
        const DELIM = "\0"
        const ACS_NETWORK_ENDPOINTS = {
            'search-api':'access/search-api/ipallowlists',
            'hec':'access/hec/ipallowlists',
            's2s':'access/s2s/ipallowlists',
            'search-ui':'access/search-ui/ipallowlists',
            'idm-ui':'access/idm-ui/ipallowlists',
            'idm-api':'access/idm-api/ipallowlists',
            
        }
        const ISORT = function(a,b){return a.localeCompare(b, undefined, {sensitivity: 'base'})}
        
        function imgError(image){
            console.log(image)
            image.onerror = "";
            image.src = "{{SPLUNKWEB_URL_PREFIX}}/static/app/badacs/appIcon.png";
            return true;
        }

        Vue.prototype.localStorage = window.localStorage
        Vue.use(KeenUI);

        Vue.component('removable', {
            data: function(){
                return {
                    loading: false
                }
            },
            props: ['action','args','value'],
            methods: {
                handler() {
                    this.loading = true
                    this.action(this.value, ...this.args).then(()=>{
                        this.loading = false
                    })
                }
            },
            template: `<div class="removable">{{value}} <ui-icon-button size="mini" type="secondary" icon="backspace" color="red" :loading="loading" @click="handler" title="Remove"></ui-icon-button></div>`
        })

        Vue.component('addable', {
            data: function(){
                return {
                    value: "",
                    loading: false,
                    error: ""
                }
            },
            props: ['action','args','placeholder'],
            methods: {
                handler() {
                    this.loading = true
                    this.error = ""
                    console.log(this.action)
                    this.action(this.value, ...this.args).then(()=>{
                        this.loading = false
                        this.value = ""
                    },reject=>{
                        this.loading = false
                        this.error = reject
                    })
                }
            },
            template: `
            <div class="addable">
                <ui-textbox :placeholder="placeholder" v-model="value" :error="error" style="float:left;"></ui-textbox>
                <ui-icon-button size="mini" type="secondary" icon="add" color="green" :loading="loading" @click="handler" title="Add" style="float:left;"></ui-icon-button> {{error}}
            </div>
            `
        })

        Vue.component('saveable', {
            data: function(){
                return {
                    loading: false,
                    error: false,
                    tooltip: ""
                }
            },
            props: ['action','args'],
            methods: {
                handler() {
                    this.loading = true
                    this.error = false
                    this.tooltip = ""
                    this.action(...this.args).then(()=>{
                        this.loading = false
                    },reject=>{
                        this.loading = false
                        this.error = true
                        this.tooltip = reject.message
                    })
                }
            },
            template: `<ui-icon-button icon="save" :color="error ? 'red' : 'primary'" :loading="loading" :tooltip="tooltip" @click="handler"></ui-icon-button>`
        })

        Vue.component('addport', {
            data: function(){
                return {
                    reason: "",
                    port: 0,
                    subnets: "",
                    loading: false,
                    error: ""
                }
            },
            props: ['action','stack'],
            methods: {
                handler() {
                    this.loading = true
                    this.error = ""
                    this.action(this.reason, this.port, this.subnets, this.stack).then(()=>{
                        this.loading = false
                        this.reason = ""
                        this.port = 0
                        this.subnets = ""
                        this.error = ""
                    },reject=>{
                        this.loading = false
                        this.error = reject
                    })
                }
            },
            template: `
            <div class="addable flex">
                <ui-textbox class=".grow" v-model="reason">Reason</ui-textbox>
                <ui-textbox class=".grow" type="number" v-model:number="port" :min="1" :max="65535">Port</ui-textbox>
                <ui-textbox class=".grow" help="Comma seperated list of CIDR subnets" v-model="subnets" :error="error">Subnets</ui-textbox>
                <ui-icon-button size="mini" type="secondary" icon="add" color="green" :loading="loading" @click="handler" title="Add"></ui-icon-button>
            </div>
            `
        })

        const vue = new Vue({
            el: '#vue',
            data: {
                badrcm: null,
                context: {},
                config: {},
                setting_columns_option: "2",
                addstack_host: "",
                addstack_host_error: "",
                addstack_auth: "",
                addstack_auth_error: "",
                addstack_shared: true,
                valid_line: RegExp('^[^#=]+=[^=]+$'),
                SPLUNKD_PATH: `/${window.$C.LOCALE}/splunkd/__raw/servicesNS/${window.$C.USERNAME}`,
                acs_columns: Array.from({length:COLUMNS_MAX}, u => ({
                    server: '',
                    loading: 0,
                })),
                netin_data: {},
                netout_data: {},
                hec_data: {},
                idx_data: {},
                app_data: {},
                IDX_ICON: {'event':'article','metric':'analytics'},
                ACS_NETWORK_ENDPOINTS: ACS_NETWORK_ENDPOINTS
            },
            computed: {
                acs_servers_options(){
                    return Object.keys(this.config)
                },
                setting_columns() {
                    return Number(this.setting_columns_option)
                },
                setting_columns_options() {
                    let start = 1
                    let end = COLUMNS_MAX
                    return [...Array(end-start+1).keys()].map(i => String(i + start));
                },
                active_columns(){
                    return this.acs_columns.slice(0,this.setting_columns)
                },
                active_stacks(){
                    return Array.from(new Set(this.active_columns.map(c => c.server).filter(c => c)))
                },
                idx_list(){
                    return this.Aus(this.active_stacks.map(s => Object.keys(this.idx_data[s] || {})).flat())
                }
            },
            methods: {
                //
                // Add Server Tab
                //
                AddStack(){
                    const values = {
                        stack:this.addstack_host,
                        token:this.addstack_auth,
                        shared:this.addstack_shared
                    }
                    this.Request('addstack',values).then(resp => {
                        console.log(resp)
                        this.addstack_host = ""
                        this.addstack_host_error = ""
                        this.addstack_auth = ""
                        this.addstack_auth_error = ""
                        this.addstack_shared = true
                        //return this.TabConfig() // Can likely do this locally
                    },reject => {
                        if(reject.cause == 401){
                            this.addstack_host_error = ""
                            this.addstack_auth_error = reject.message
                        } else {
                            this.addstack_host_error = reject.message
                            this.addstack_auth_error = ""
                        }
                    })
                },
                //
                // NETIN Tab
                //
                NetInGet(c){
                    console.log("NetInGet",c)
                    if(!this.config.hasOwnProperty(c.server)) return Promise.resolve()
                    if(!this.netin_data.hasOwnProperty(c.server)){
                        this.$set(this.netin_data,c.server,{})
                    }
                    c.loading += 1
                    return Promise.all(Object.entries(ACS_NETWORK_ENDPOINTS).map(z => {
                        const [key,endpoint] = z
                        if(this.netin_data[c.server].hasOwnProperty(key)) return Promise.resolve()
                        return this.Request('get',{'stack':c.server,'endpoint':endpoint})
                        .then(resp => {
                            this.$set(this.netin_data[c.server],key,resp.subnets)
                        }, reject =>{
                            this.$set(this.netin_data[c.server],key,{})
                        })
                    }))
                    .then(()=>{
                        c.loading -= 1
                    })
                },
                NetInRemove(value,stack,aspect,index){
                    console.log("NetInRemove",value,stack,aspect)
                    return this.Request('change',{'method':'DELETE', 'stack':stack, 'endpoint':ACS_NETWORK_ENDPOINTS[aspect], 'data':JSON.stringify({'subnets':[value]})}).then(()=>{
                        this.$delete(this.netin_data[stack][aspect],index) //this.netin_data[stack][aspect].indexOf(value)
                    },reject => {
                        return Promise.reject(reject.message)
                    })
                },
                NetInAdd(value,stack,aspect){
                    console.log("NetInAdd",value,stack,aspect)
                    return this.Request('change',{'method':'POST', 'stack':stack, 'endpoint':ACS_NETWORK_ENDPOINTS[aspect], 'data':JSON.stringify({'subnets':[value]})}).then(()=>{
                        this.netin_data[stack][aspect].push(value)
                    },reject => {
                        return Promise.reject(reject.message)
                    })
                },
                //
                // NETOUT Tab
                //
                NetOutGet(c){
                    console.log("NetOutGet",c)
                    if(!this.config.hasOwnProperty(c.server)) return Promise.resolve()
                    if(!this.netout_data.hasOwnProperty(c.server)){
                        this.$set(this.netout_data,c.server,{})
                    }
                    c.loading += 1
                    return this.Request('get',{'stack':c.server,'endpoint':'access/outbound-ports'})
                    .then(resp => {
                        this.$set(this.netout_data,c.server,resp)
                        c.loading -= 1
                    }, reject => {
                        this.$set(this.netout_data,c.server,[])
                        c.loading -= 1
                    })
                },
                NetOutRemove(value,stack,port,x,y){
                    console.log("NetOutRemove",port,value,stack)
                    return this.Request('change',{'method':'DELETE', 'stack':stack, 'endpoint':`access/outbound-ports/${port}`, 'data':JSON.stringify({'subnets':[value]})}).then(()=>{
                        if(this.netout_data[stack][x].subnets.length > 1){
                            this.$delete(this.netout_data[stack][x].destinationRanges,u)
                        } else {
                            this.$delete(this.netout_data[stack],x)
                        }
                    },reject => {
                        return Promise.reject(reject.message)
                    })
                },
                NetOutAdd(reason,port,subnets,stack){
                    console.log("NetOutAdd",reason,port,subnets,stack)
                    subnets = subnets.split(',').map(s => s.trim())
                    const payload = {
                        'outboundPorts': [{
                            'port': Number(port),
                            'subnets': subnets
                        }],
                        'reason': reason
                    }
                    return this.Request('change',{'method':'POST', 'stack':stack, 'endpoint':'access/outbound-ports', 'data':JSON.stringify(payload)}).then(()=>{
                        this.netout_data[stack].push({
                            "destinationRanges": subnets,
                            "name": port,
                            "port": port
                        })
                    },reject => {
                        return Promise.reject(reject.message)
                    })
                },
                //
                // HEC
                //
                HecGet(c){
                    if(!this.config.hasOwnProperty(c.server)) return Promise.resolve()
                    if(this.hec_data.hasOwnProperty(c.server)) return Promise.resolve()

                    c.loading += 1
                    
                    return Promise.all([ // HEC also needs the index list, so grab that first
                        this.Request('get',{'stack':c.server,'endpoint':'inputs/http-event-collectors'}),
                        this.IdxGet(c)
                    ])
                    .then(resp => {
                        const data = resp[0]['http-event-collectors'].reduce((x,a)=>{
                            x[a.token] = a.spec
                            return x
                        },{})
                        this.$set(this.hec_data,c.server,data)
                        c.loading -= 1
                    }, reject => {
                        this.$set(this.hec_data,c.server,null)
                        c.loading -= 1
                    })
                },
                HecNew(stack,hec){

                },
                HecChange(stack,hec){
                    return this.Request('change',{'stack':stack, 'method':'PUT', 'endpoint':`inputs/http-event-collectors/${hec.name}`, data: JSON.stringify(hec)})
                },
                //
                // Indexes
                //
                IdxGet(c){
                    console.log("IdxGet",c)
                    if(!this.config.hasOwnProperty(c.server)) return Promise.resolve()
                    if(this.idx_data.hasOwnProperty(c.server)) return Promise.resolve()
                    c.loading += 1
                    
                    return this.Request('get',{'stack':c.server,'endpoint':'indexes'})
                    .then(resp => {
                        console.log("good",resp)
                        const data = resp.reduce((x,a)=>{
                            x[a.name] = a
                            return x
                        },{})
                        this.$set(this.idx_data,c.server,data)
                        c.loading -= 1
                    }, reject => {
                        console.log("bad",reject)
                        this.$set(this.idx_data,c.server,null)
                        c.loading -= 1
                    })
                },
                IdxChange(stack,idx){
                    return this.Request('change',{'stack':stack, 'method':'PATCH', 'endpoint':`indexes/${idx.name}`, data: JSON.stringify({'searchableDays': idx.searchableDays, 'maxDataSizeMB': idx.maxDataSizeMB})})
                },
                //
                // Generic Helpers
                //
                Afus(a){ //Arrays Flat Unique Sorted 
                    return Array.from(new Set(a.flat())).sort() // Remove .flat() eventually
                },
                Aus(a){ //Arrays Unique Sorted 
                    return Array.from(new Set(a)).sort(ISORT)
                },
                Options(){
                    return Array.from(new Set([...arguments].flat()))
                },
                Loading(e){
                    console.log(e)
                },
                Request(action,data={}) {
                    let form = new URLSearchParams()
                    form.append('a', action)
                    for (x in data){
                        form.append(x, data[x])
                    }

                    console.log(form.toString())
                    return fetch(REST_ENDPOINT, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                            'X-Requested-With': 'XMLHttpRequest',
                            'X-Splunk-Form-Key': CSRF,
                        },
                        body: form
                    })
                    .catch(e => {
                        console.warn(e)
                        this.$refs.errorbar.createSnackbar({
                            message: e.message
                        });
                        return Promise.reject({ cause: 'local', message: e.message });
                    })
                    .then(resp => {
                        console.log(resp.status)
                        json = resp.json().catch(e => {
                            console.warn(e)
                            return resp.text().catch(()=>{
                                return resp.reason
                            }).then(text => {
                                this.$refs.errorbar.createSnackbar({
                                    message: text
                                });
                                return Promise.reject({ cause: 'parse', message: text });
                            })
                        })
                        if (resp.status == 200) return json
                        return json.then(data => {
                            console.warn(resp.status, data)
                            
                            this.$refs.errorbar.createSnackbar({
                                message: data.error ? `${data.message}. ${data.error}` : data.message
                            });
                            return Promise.reject({ cause: resp.status, message: data.message})
                        })
                    })
                },
                /*Request(action,data={}) {
                    let form = new URLSearchParams()
                    form.append('a', action)
                    for (x in data){
                        form.append(x, data[x])
                    }
                    console.log(form.toString())
                    return fetch(`/${window.$C.LOCALE}/splunkd/__raw/services/badacs?output_mode=json`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                            'X-Requested-With': 'XMLHttpRequest',
                            'X-Splunk-Form-Key': CSRF,
                        },
                        body: form
                    })
                    .catch(e => {
                        console.warn(e)
                        return Promise.reject({ cause: 'local', message: e.message });
                    })
                    .then(resp => {
                        console.log(resp.status)
                        return resp.json().catch(e => {
                            console.error("JSON PARSE",e,resp)
                            return Promise.reject({ cause: 'parse', message: e.message });
                        }).then(data=>{
                            console.log(resp.status)
                            if (resp.status >= 500){
                                console.error(resp.status, data.error, data.message)
                                return Promise.reject({ cause: resp.status, message: "There was a server error, please report this on GitHub", error: data.message})
                            } else if (resp.status >= 400){
                                console.warn(resp.status, data.error, data.message)
                                return Promise.reject({ cause: resp.status, message: data.message, error: data.error})
                            }
                            return data
                        })
                        
                    })
                },*/
                GetChild(object, keys, def=false) {
                    for (const key of keys){
                        if (object.hasOwnProperty(key)){
                            object = object[key]
                        } else return def
                    }
                    return object
                },
                TabChange(func){
                    for (const c of this.acs_columns){
                        if(c.server){
                            func(c)
                        }
                    }
                }
            },
            mounted() {
                if(localStorage.badacs_setting_columns){
                    this.$set(this, 'setting_columns_option', localStorage.badacs_setting_columns)
                }
                this.Request('config').then(resp => {
                    this.$set(this,'config',resp)
                },reject =>{
                    console.error("FATAL ERROR - COULDNT GET CONFIG",reject)
                })

                // Check if BADRCM is installed
                fetch(`/${window.$C.LOCALE}/splunkd/__raw/services/badrcm`, {
                    method: 'GET',
                    headers: {
                        'X-Requested-With': 'XMLHttpRequest',
                        'X-Splunk-Form-Key': CSRF,
                    }
                }).catch(()=>{
                    this.badrcm = false
                }).then(()=>{
                    this.badrcm = true
                })
            },
            watch: {
                setting_columns_option(next,prev){
                    localStorage.setItem('badacs_setting_columns', next)
                },
            }
        })
    </script>
</body>
</html>